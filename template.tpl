___TERMS_OF_SERVICE___

By creating or modifying this file you agree to Google Tag Manager's Community
Template Gallery Developer Terms of Service available at
https://developers.google.com/tag-manager/gallery-tos (or such other URL as
Google may provide), as modified from time to time.


___INFO___

{
  "type": "TAG",
  "id": "cvt_temp_public_id",
  "version": 1,
  "securityGroups": [],
  "displayName": "LinkedIn Conversion API",
  "brand": {
    "id": "brand_dummy",
    "displayName": "",
    "thumbnail": "data:image/png;base64,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\u003d\u003d"
  },
  "description": "Tag that sends the event data from the GA4/Data client to LinkedIn Conversion API.",
  "containerContexts": [
    "SERVER"
  ]
}


___TEMPLATE_PARAMETERS___

[
  {
    "type": "RADIO",
    "name": "type",
    "displayName": "Event Type",
    "radioItems": [
      {
        "value": "page_view",
        "displayValue": "Page View"
      },
      {
        "value": "conversion",
        "displayValue": "Conversion"
      }
    ],
    "simpleValueType": true,
    "help": "\u003cb\u003ePage View\u003c/b\u003e - stores the li_fat_id URL parameter inside the li_fat_id cookie\u003cbr\u003e\u003cbr\u003e \u003cb\u003eConversion\u003c/b\u003e - Send request with data about the conversion to the LinkedIn",
    "defaultValue": "conversion"
  },
  {
    "type": "TEXT",
    "name": "accessToken",
    "displayName": "Access Token",
    "simpleValueType": true,
    "help": "LinkedIn API access token \u003ca href\u003d\"https://www.linkedin.com/help/lms/answer/a1718034\"\u003eLearn more\u003c/a\u003e",
    "valueValidators": [
      {
        "type": "NON_EMPTY"
      }
    ],
    "enablingConditions": [
      {
        "paramName": "type",
        "paramValue": "conversion",
        "type": "EQUALS"
      }
    ]
  },
  {
    "type": "TEXT",
    "name": "conversionRuleUrn",
    "displayName": "Conversion Rule ID",
    "simpleValueType": true,
    "valueValidators": [
      {
        "type": "NON_EMPTY"
      }
    ],
    "enablingConditions": [
      {
        "paramName": "type",
        "paramValue": "conversion",
        "type": "EQUALS"
      }
    ]
  },
  {
    "displayName": "Event Data Override",
    "name": "eventDataGroup",
    "groupStyle": "ZIPPY_CLOSED",
    "type": "GROUP",
    "subParams": [
      {
        "name": "eventData",
        "simpleTableColumns": [
          {
            "valueValidators": [
              {
                "type": "NON_EMPTY"
              }
            ],
            "defaultValue": "conversionHappenedAt",
            "displayName": "Property Name",
            "name": "name",
            "isUnique": true,
            "type": "SELECT",
            "selectItems": [
              {
                "value": "conversionHappenedAt",
                "displayValue": "Conversion Happened At"
              },
              {
                "value": "currency",
                "displayValue": "Currency"
              },
              {
                "value": "amount",
                "displayValue": "Amount"
              },
              {
                "value": "eventId",
                "displayValue": "Event ID"
              }
            ]
          },
          {
            "defaultValue": "",
            "displayName": "Property Value",
            "name": "value",
            "type": "TEXT"
          }
        ],
        "type": "SIMPLE_TABLE",
        "newRowButtonText": "Add property",
        "valueValidators": []
      }
    ],
    "enablingConditions": [
      {
        "paramName": "type",
        "paramValue": "conversion",
        "type": "EQUALS"
      }
    ]
  },
  {
    "displayName": "User Ids Override",
    "name": "userIdsGroup",
    "type": "GROUP",
    "subParams": [
      {
        "type": "LABEL",
        "name": "userIdsLabel",
        "displayName": "Tag will attempt to parse cookie/event data but you can provide those parameter explicitly, at least one identifier is needed for a successful request."
      },
      {
        "name": "userIds",
        "simpleTableColumns": [
          {
            "valueValidators": [
              {
                "type": "NON_EMPTY"
              }
            ],
            "defaultValue": "email",
            "displayName": "Property Name",
            "name": "name",
            "isUnique": true,
            "type": "SELECT",
            "selectItems": [
              {
                "value": "email",
                "displayValue": "SHA256_EMAIL"
              },
              {
                "value": "linkedinFirstPartyId",
                "displayValue": "LINKEDIN_FIRST_PARTY_ADS_TRACKING_UUID"
              },
              {
                "value": "acxiomID",
                "displayValue": "ACXIOM ID"
              },
              {
                "value": "moatID",
                "displayValue": "ORACLE_MOAT_ID"
              }
            ]
          },
          {
            "defaultValue": "",
            "displayName": "Property Value",
            "name": "value",
            "type": "TEXT"
          }
        ],
        "type": "SIMPLE_TABLE",
        "newRowButtonText": "Add property"
      }
    ],
    "groupStyle": "ZIPPY_CLOSED",
    "enablingConditions": [
      {
        "paramName": "type",
        "paramValue": "conversion",
        "type": "EQUALS"
      }
    ]
  },
  {
    "displayName": "User Info Override",
    "name": "userInfoGroup",
    "groupStyle": "ZIPPY_CLOSED",
    "type": "GROUP",
    "subParams": [
      {
        "name": "userInfo",
        "simpleTableColumns": [
          {
            "valueValidators": [
              {
                "type": "NON_EMPTY"
              }
            ],
            "defaultValue": "firstName",
            "displayName": "Property Name",
            "name": "name",
            "isUnique": true,
            "type": "SELECT",
            "selectItems": [
              {
                "value": "firstName",
                "displayValue": "First Name"
              },
              {
                "value": "lastName",
                "displayValue": "Last Name"
              },
              {
                "value": "jobTitle",
                "displayValue": "Job Title"
              },
              {
                "value": "companyName",
                "displayValue": "Company Name"
              },
              {
                "value": "countryCode",
                "displayValue": "Country Code"
              }
            ]
          },
          {
            "defaultValue": "",
            "displayName": "Property Value",
            "name": "value",
            "type": "TEXT"
          }
        ],
        "type": "SIMPLE_TABLE",
        "newRowButtonText": "Add property"
      }
    ],
    "enablingConditions": [
      {
        "paramName": "type",
        "paramValue": "conversion",
        "type": "EQUALS"
      }
    ]
  },
  {
    "type": "GROUP",
    "name": "consentSettingsGroup",
    "displayName": "Consent Settings",
    "groupStyle": "ZIPPY_CLOSED",
    "subParams": [
      {
        "type": "RADIO",
        "name": "adStorageConsent",
        "displayName": "",
        "radioItems": [
          {
            "value": "optional",
            "displayValue": "Send data always"
          },
          {
            "value": "required",
            "displayValue": "Send data in case marketing consent given"
          }
        ],
        "simpleValueType": true,
        "defaultValue": "optional"
      }
    ]
  },
  {
    "displayName": "Logs Settings",
    "name": "logsGroup",
    "groupStyle": "ZIPPY_CLOSED",
    "type": "GROUP",
    "subParams": [
      {
        "type": "RADIO",
        "name": "logType",
        "radioItems": [
          {
            "value": "no",
            "displayValue": "Do not log"
          },
          {
            "value": "debug",
            "displayValue": "Log to console during debug and preview"
          },
          {
            "value": "always",
            "displayValue": "Always log to console"
          }
        ],
        "simpleValueType": true,
        "defaultValue": "debug"
      }
    ]
  }
]


___SANDBOXED_JS_FOR_SERVER___

const getAllEventData = require('getAllEventData');
const JSON = require('JSON');
const sendHttpRequest = require('sendHttpRequest');
const getContainerVersion = require('getContainerVersion');
const logToConsole = require('logToConsole');
const sha256Sync = require('sha256Sync');
const getRequestHeader = require('getRequestHeader');
const getType = require('getType');
const makeString = require('makeString');
const encodeUriComponent = require('encodeUriComponent');
const getTimestampMillis = require('getTimestampMillis');
const Math = require('Math');
const makeNumber = require('makeNumber');
const makeTableMap = require('makeTableMap');
const getCookieValues = require('getCookieValues');
const decodeUriComponent = require('decodeUriComponent');
const parseUrl = require('parseUrl');
const setCookie = require('setCookie');

const isLoggingEnabled = determinateIsLoggingEnabled();
const traceId = isLoggingEnabled ? getRequestHeader('trace-id') : undefined;
const cookieName = 'li_fat_id';

const eventData = getAllEventData();

if (!isConsentGivenOrNotRequired()) {
  return data.gtmOnSuccess();
}

if (data.type === 'page_view') {
  const url = eventData.page_location || getRequestHeader('referer');

  if (url) {
    const value = parseUrl(url).searchParams[cookieName];

    if (value) {
      const options = {
        domain: 'auto',
        path: '/',
        secure: true,
        httpOnly: false,
        'max-age': 86400 * 90
      };

      setCookie(cookieName, value, options, false);
    }
  }

  return data.gtmOnSuccess();
}

const user_data = eventData.user_data || {};

let user_address = user_data.address;
if (['array', 'object'].indexOf(getType(user_address)) === -1) {
  user_address = {};
}
user_address = user_address[0] || user_address || {};

const eventDataOverride = makeOverrideTableMap(data.eventData);
const userIdsOverride = makeOverrideTableMap(data.userIds);
const userInfoOverride = makeOverrideTableMap(data.userInfo);

const postUrl = getRequestUrl();
const postBody = getPostBody();
const postHeaders = getRequestHeaders();

if (isLoggingEnabled) {
  logToConsole(
    JSON.stringify({
      Name: 'LinkedIn',
      Type: 'Request',
      TraceId: traceId,
      EventName: postBody.eventId,
      RequestMethod: 'POST',
      RequestUrl: postUrl,
      RequestBody: postBody
    })
  );
}

// perform validation check on presence of 1/4 of the required IDs. If at least 1 ID is present, make the API call. If no IDs are present, log the warning and no call is made
if (validateUserData()) {
  sendConversionToLinkedIn();
} else {
  if (isLoggingEnabled) {
    logToConsole(
      JSON.stringify({
        Name: 'LinkedIn',
        Type: 'Message',
        TraceId: traceId,
        EventName: postBody.eventId,
        Message: 'No conversion event was sent to LinkedIn CAPI.',
        Reason:
          'You must set 1 out of the 4 acceptable IDs (SHA256_EMAIL, LINKEDIN_FIRST_PARTY_ADS_TRACKING_UUID, ACXIOM_ID, ORACLE_MOAT_ID) to resolve this issue or make certain to send both firstName and lastName.'
      })
    );
  }

  data.gtmOnFailure();
}

function validateUserData() {
  if (postBody.user.userIds.length > 0) {
    return true;
  }

  return postBody.user.userInfo.firstName && postBody.user.userInfo.lastName;
}

function sendConversionToLinkedIn() {
  sendHttpRequest(
    postUrl,
    (statusCode, headers, body) => {
      if (isLoggingEnabled) {
        logToConsole(
          JSON.stringify({
            Name: 'LinkedIn',
            Type: 'Response',
            TraceId: traceId,
            EventName: postBody.eventId,
            ResponseStatusCode: statusCode,
            ResponseHeaders: headers,
            ResponseBody: body
          })
        );
      }

      if (statusCode >= 200 && statusCode < 300) {
        data.gtmOnSuccess();
      } else {
        data.gtmOnFailure();
      }
    },
    {
      headers: postHeaders,
      method: 'POST'
    },
    JSON.stringify(postBody)
  );
}

function getRequestUrl() {
  return 'https://api.linkedin.com/rest/conversionEvents';
}

function getRequestHeaders() {
  return {
    'Content-Type': 'application/json',
    Authorization: 'Bearer ' + data.accessToken,
    'LinkedIn-Version': '202406',
    'X-Restli-Protocol-Version': '2.0.0'
  };
}

function getPostBody() {
  const result = {
    conversion: getConversionRuleUrn(),
    conversionHappenedAt: getConversionHappenedAt(),
    eventId: getEventId(),
    user: {
      userIds: getUserIds(),
      userInfo: getUserInfo()
    }
  };
  const conversionValue = getConversionValue();
  if (conversionValue) result.conversionValue = conversionValue;
  return result;
}

function getConversionRuleUrn() {
  return 'urn:lla:llaPartnerConversion:' + data.conversionRuleUrn;
}

function getConversionHappenedAt() {
  if (eventDataOverride.conversionHappenedAt)
    return makeNumber(eventDataOverride.conversionHappenedAt);
  if (eventData.conversion_happened_at)
    return makeNumber(eventData.conversion_happened_at);
  if (eventData.event_time) return makeNumber(eventData.event_time);
  return Math.round(getTimestampMillis());
}

function getConversionValue() {
  const hasItems = getType(eventData.items) === 'array' && !!eventData.items[0];
  const itemsCurrency = hasItems ? eventData.items[0].currency : '';
  const currencyCode =
    eventDataOverride.currency || eventData.currency || itemsCurrency;
  if (!currencyCode) return null;
  const itemsValue = hasItems
    ? eventData.items.reduce((acc, item) => {
        const price = item.price || 0;
        const quantity = item.quantity || 1;
        return acc + price * quantity;
      }, 0)
    : 0;
  const amount = eventDataOverride.amount || eventData.value || itemsValue;
  return {
    currencyCode: currencyCode,
    amount: makeString(amount)
  };
}

function getEventId() {
  return (
    eventDataOverride.eventId || eventData.eventId || eventData.event_id || ''
  );
}

function getUserIds() {
  const userIds = [
    {
      idType: 'SHA256_EMAIL',
      idValue: hashData(getUserEmail())
    },
    {
      idType: 'LINKEDIN_FIRST_PARTY_ADS_TRACKING_UUID',
      idValue: getLinkedInFirstPartyAdsTrackingUuid()
    },
    {
      idType: 'ACXIOM_ID',
      idValue: getAcxiomId()
    },
    {
      idType: 'ORACLE_MOAT_ID',
      idValue: getOracleMoatId()
    }
  ];

  return userIds.filter((userId) => userId.idValue);
}

function getUserIdFactory(idType, getIdValue) {
  return {
    idType: idType,
    idValue: getIdValue
  };
}

function getUserEmail() {
  return (
    userIdsOverride.email ||
    eventData.email ||
    user_data.email_address ||
    user_data.email ||
    ''
  );
}

function getLinkedInFirstPartyAdsTrackingUuid() {
  const liFatId = decodeUriComponent(getCookieValues(cookieName)[0] || '');
  return (
    liFatId ||
    userIdsOverride.linkedinFirstPartyId ||
    user_data.linkedinFirstPartyId ||
    ''
  );
}

function getAcxiomId() {
  return userIdsOverride.acxiomID || user_data.acxiomID || '';
}

function getOracleMoatId() {
  return userIdsOverride.moatID || user_data.moatID || '';
}

function getUserFirstName() {
  return (
    userInfoOverride.firstName ||
    eventData.firstName ||
    eventData.FirstName ||
    eventData.nameFirst ||
    eventData.first_name ||
    user_data.first_name ||
    user_address.first_name ||
    ''
  );
}

function getUserLastName() {
  return (
    userInfoOverride.lastName ||
    eventData.lastName ||
    eventData.LastName ||
    eventData.nameLast ||
    eventData.last_name ||
    user_data.last_name ||
    user_address.last_name ||
    ''
  );
}

function getUserJobTitle() {
  return (
    userInfoOverride.jobTitle ||
    eventData.jobTitle ||
    user_data.jobTitle ||
    user_data.job_title ||
    ''
  );
}

function getUserCompanyName() {
  return (
    userInfoOverride.companyName ||
    eventData.companyName ||
    eventData.company_name ||
    user_data.companyName ||
    user_data.company_name ||
    ''
  );
}

function getUserCountryCode() {
  return (
    userInfoOverride.countryCode ||
    eventData.countryCode ||
    eventData.country ||
    user_data.country ||
    user_address.country ||
    ''
  );
}

function getUserInfo() {
  return {
    firstName: getUserFirstName(),
    lastName: getUserLastName(),
    title: getUserJobTitle(),
    companyName: getUserCompanyName(),
    countryCode: getUserCountryCode()
  };
}

function isHashed(value) {
  if (!value) {
    return false;
  }

  return makeString(value).match('^[A-Fa-f0-9]{64}$') !== null;
}

function hashData(value) {
  if (!value) {
    return value;
  }

  const type = getType(value);

  if (type === 'undefined' || value === 'undefined') {
    return undefined;
  }

  if (type === 'object' || type === 'array') {
    return value;
  }

  if (isHashed(value)) {
    return value;
  }

  value = makeString(value).trim().toLowerCase();

  return sha256Sync(value, { outputEncoding: 'hex' });
}

function enc(data) {
  return encodeUriComponent(data || '');
}

function makeOverrideTableMap(values) {
  return makeTableMap(values || [], 'name', 'value') || {};
}

function determinateIsLoggingEnabled() {
  const containerVersion = getContainerVersion();
  const isDebug = !!(
    containerVersion &&
    (containerVersion.debugMode || containerVersion.previewMode)
  );

  if (!data.logType) {
    return isDebug;
  }

  if (data.logType === 'no') {
    return false;
  }

  if (data.logType === 'debug') {
    return isDebug;
  }

  return data.logType === 'always';
}

function isConsentGivenOrNotRequired() {
  if (data.adStorageConsent !== 'required') return true;
  if (eventData.consent_state) return !!eventData.consent_state.ad_storage;
  const xGaGcs = eventData['x-ga-gcs'] || ''; // x-ga-gcs is a string like "G110"
  return xGaGcs[2] === '1';
}


___SERVER_PERMISSIONS___

[
  {
    "instance": {
      "key": {
        "publicId": "read_request",
        "versionId": "1"
      },
      "param": [
        {
          "key": "headerWhitelist",
          "value": {
            "type": 2,
            "listItem": [
              {
                "type": 3,
                "mapKey": [
                  {
                    "type": 1,
                    "string": "headerName"
                  }
                ],
                "mapValue": [
                  {
                    "type": 1,
                    "string": "trace-id"
                  }
                ]
              },
              {
                "type": 3,
                "mapKey": [
                  {
                    "type": 1,
                    "string": "headerName"
                  }
                ],
                "mapValue": [
                  {
                    "type": 1,
                    "string": "referer"
                  }
                ]
              }
            ]
          }
        },
        {
          "key": "headersAllowed",
          "value": {
            "type": 8,
            "boolean": true
          }
        },
        {
          "key": "requestAccess",
          "value": {
            "type": 1,
            "string": "specific"
          }
        },
        {
          "key": "headerAccess",
          "value": {
            "type": 1,
            "string": "specific"
          }
        },
        {
          "key": "queryParameterAccess",
          "value": {
            "type": 1,
            "string": "any"
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "logging",
        "versionId": "1"
      },
      "param": [
        {
          "key": "environments",
          "value": {
            "type": 1,
            "string": "all"
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "read_container_data",
        "versionId": "1"
      },
      "param": []
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "read_event_data",
        "versionId": "1"
      },
      "param": [
        {
          "key": "eventDataAccess",
          "value": {
            "type": 1,
            "string": "any"
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "send_http",
        "versionId": "1"
      },
      "param": [
        {
          "key": "allowedUrls",
          "value": {
            "type": 1,
            "string": "specific"
          }
        },
        {
          "key": "urls",
          "value": {
            "type": 2,
            "listItem": [
              {
                "type": 1,
                "string": "https://api.linkedin.com/rest/conversionEvents"
              }
            ]
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "get_cookies",
        "versionId": "1"
      },
      "param": [
        {
          "key": "cookieAccess",
          "value": {
            "type": 1,
            "string": "specific"
          }
        },
        {
          "key": "cookieNames",
          "value": {
            "type": 2,
            "listItem": [
              {
                "type": 1,
                "string": "li_fat_id"
              }
            ]
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "set_cookies",
        "versionId": "1"
      },
      "param": [
        {
          "key": "allowedCookies",
          "value": {
            "type": 2,
            "listItem": [
              {
                "type": 3,
                "mapKey": [
                  {
                    "type": 1,
                    "string": "name"
                  },
                  {
                    "type": 1,
                    "string": "domain"
                  },
                  {
                    "type": 1,
                    "string": "path"
                  },
                  {
                    "type": 1,
                    "string": "secure"
                  },
                  {
                    "type": 1,
                    "string": "session"
                  }
                ],
                "mapValue": [
                  {
                    "type": 1,
                    "string": "li_fat_id"
                  },
                  {
                    "type": 1,
                    "string": "*"
                  },
                  {
                    "type": 1,
                    "string": "*"
                  },
                  {
                    "type": 1,
                    "string": "any"
                  },
                  {
                    "type": 1,
                    "string": "any"
                  }
                ]
              }
            ]
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  }
]


___TESTS___

scenarios:
- name: User data address is object and properties are at the root level
  code: "const mockGetAllEventData = {\n  user_data: { \n    address: {\n      country:\
    \ \"Brazil\",\n      first_name: \"Test First Name\",\n      last_name: \"Test\
    \ Last Name\",\n      qweqwewa: 123123\n    }   \n  }\n};\n\nmock('getAllEventData',\
    \ mockGetAllEventData);\n\nmock('sendHttpRequest', function(url, callback, headers,\
    \ body) {\n  const parsedBody = JSON.parse(body);\n  if (parsedBody && parsedBody.user\
    \ && parsedBody.user.userInfo) {\n    assertThat(parsedBody.user.userInfo.firstName).isEqualTo(mockGetAllEventData.user_data.address.first_name);\n\
    \    assertThat(parsedBody.user.userInfo.lastName).isEqualTo(mockGetAllEventData.user_data.address.last_name);\n\
    \    assertThat(parsedBody.user.userInfo.countryCode).isEqualTo(mockGetAllEventData.user_data.address.country);\n\
    \  }\n});\n\nrunCode(mockData);"
- name: User data address is object with properties in a nested object in the '0'
    key
  code: "const mockGetAllEventData = {\n  user_data: { \n    address: {\n      0:\
    \ {\n        country: \"Brazil\",\n        first_name: \"Test First Name\",\n\
    \        last_name: \"Test Last Name\"\n      }\n    }  \n  }\n};\n\nmock('getAllEventData',\
    \ mockGetAllEventData);\n\nmock('sendHttpRequest', function(url, callback, headers,\
    \ body) {\n  const parsedBody = JSON.parse(body);\n  if (parsedBody && parsedBody.user\
    \ && parsedBody.user.userInfo) {\n    assertThat(parsedBody.user.userInfo.firstName).isEqualTo(mockGetAllEventData.user_data.address[0].first_name);\n\
    \    assertThat(parsedBody.user.userInfo.lastName).isEqualTo(mockGetAllEventData.user_data.address[0].last_name);\n\
    \    assertThat(parsedBody.user.userInfo.countryCode).isEqualTo(mockGetAllEventData.user_data.address[0].country);\n\
    \  }\n});\n\nrunCode(mockData);"
- name: User data address is array with properties in an object at the first position
  code: "const mockGetAllEventData = {\n  user_data: { \n    address: [{\n      first_name:\
    \ \"Test First Name\",\n      last_name: \"Test Last Name\",\n      country: \"\
    Brazil\",\n      postal_code: \"example.com\"\n    }]\n  }\n};\n\nmock('getAllEventData',\
    \ mockGetAllEventData);\n\nmock('sendHttpRequest', function(url, callback, headers,\
    \ body) {\n  const parsedBody = JSON.parse(body);\n  if (parsedBody && parsedBody.user\
    \ && parsedBody.user.userInfo) {\n    assertThat(parsedBody.user.userInfo.firstName).isEqualTo(mockGetAllEventData.user_data.address[0].first_name);\n\
    \    assertThat(parsedBody.user.userInfo.lastName).isEqualTo(mockGetAllEventData.user_data.address[0].last_name);\n\
    \    assertThat(parsedBody.user.userInfo.countryCode).isEqualTo(mockGetAllEventData.user_data.address[0].country);\n\
    \  }\n});\n\nrunCode(mockData);"
- name: User data address is empty object
  code: "const mockGetAllEventData = {\n  user_data: { \n    email: 'test@example.com',\n\
    \    address: {}\n  }\n};\n\nmock('getAllEventData', mockGetAllEventData);\n\n\
    mock('sendHttpRequest', function(url, callback, headers, body) {\n  const parsedBody\
    \ = JSON.parse(body);\n  if (parsedBody && parsedBody.user && parsedBody.user.userInfo)\
    \ {\n    if (\n      parsedBody.user.userInfo.firstName ||\n      parsedBody.user.userInfo.lastName\
    \ ||\n      parsedBody.user.userInfo.countryCode\n    ) {\n      fail('firstName,\
    \ lastName and countryCode shouldn\\'t be present when user_data.address is not\
    \ supplied.');\n    }\n  }\n});\n\nrunCode(mockData);"
- name: User data address is not supplied
  code: "const mockGetAllEventData = {\n  user_data: { \n    email: 'test@example.com'\n\
    \  }\n};\n\nmock('getAllEventData', mockGetAllEventData);\n\nmock('sendHttpRequest',\
    \ function(url, callback, headers, body) {\n  const parsedBody = JSON.parse(body);\n\
    \  if (parsedBody && parsedBody.user && parsedBody.user.userInfo) {\n    if (\n\
    \      parsedBody.user.userInfo.firstName ||\n      parsedBody.user.userInfo.lastName\
    \ ||\n      parsedBody.user.userInfo.countryCode\n    ) {\n      fail('firstName,\
    \ lastName and countryCode shouldn\\'t be present when user_data.address is not\
    \ supplied.');\n    }\n  }\n});\n\nrunCode(mockData);"
setup: |+
  const JSON = require('JSON');

  const mockData = {
    "type": "conversion",
    "accessToken": "token",
    "conversionRuleUrn": "123123"
  };


___NOTES___

Created on 18/08/2022, 12:25:26


